diff -urN sysklogd-1.4.1/CHANGES sysklogd-1.4.1-STEP/CHANGES
--- sysklogd-1.4.1/CHANGES	2001-03-12 08:35:51.000000000 +1300
+++ sysklogd-1.4.1-STEP/CHANGES	2006-04-25 06:07:13.473706976 +1200
@@ -1,3 +1,42 @@
+Version 1.4.2
+
+ . Dmitry V. Levin <ldv@altlinux.org>
+   - Close file descriptor in FindSymbolFile() in ksym.c in order not to
+     leak file descriptors.
+ . Solar Designer <solar@openwall.com>
+   - improve crunch_list()
+   - Prevent potential buffer overflow in reading messages from the
+     kernel log ringbuffer.
+   - Ensure that "len" is not placed in a register, and that the
+     endtty() signal handler is not installed too early which could
+     cause a segmentation fault or worse.
+ . Steve Grubb <linux_4ever@yahoo.com>
+   - fix memory calculation in crunch_list()
+ . Martin Schulze <joey@infodrom.org>
+   - klogd will reconnect to the logger (mostly syslogd) after it went
+     away
+   - On heavily loaded system syslog will not spit out error messages
+     anymore when recvfrom() results in EAGAIN
+   - Makefile improvements
+   - Local copy of module.h
+   - Improved sysklogd.8
+   - Always log with syslogd's timezone and locale
+   - Remove trailing newline when forwarding messages
+ . Jon Burgess <Jon_Burgess@eur.3com.com>
+   - Moved the installation of the signal handler up a little bit so it
+     guaranteed to be available when the child is forked, hence, fixing a
+     race condition.  This used to create problems with UML and fast
+     machines.
+ . Greg Trounson <gregt@maths.otago.ac.nz>
+   - Improved README.linux
+ . Ulf Härnhammar <Ulf.Harnhammar.9485@student.uu.se>
+   - Bondary check for fscanf() in InitKsyms() and CheckMapVersion()
+ . Colin Phipps <cph@cph.demon.co.uk>
+   - Don't block on the network socket in case of package los
+ . Dirk Mueller <mueller@kde.org>
+   - Don't crash when filesize limit is reached (e.g. without LFS)
+
+
 Version 1.4.1
 
  . klogd will set the console log level only if `-c' is given on the
@@ -30,3 +69,9 @@
  . Olaf Kirch <okir@caldera.de>
    - Remove Unix Domain Sockets and switch to Datagram Unix Sockets
  . Several bugfixes and improvements, please refer to the .c files
+
+
+Local variables:
+mode: indented-text
+fill-column: 72
+End:
diff -urN sysklogd-1.4.1/Makefile sysklogd-1.4.1-STEP/Makefile
--- sysklogd-1.4.1/Makefile	1998-10-13 09:25:15.000000000 +1300
+++ sysklogd-1.4.1-STEP/Makefile	2006-04-25 06:10:56.204846696 +1200
@@ -4,12 +4,15 @@
 #CFLAGS= -g -DSYSV -Wall
 #LDFLAGS= -g
 CFLAGS= $(RPM_OPT_FLAGS) -O3 -DSYSV -fomit-frame-pointer -Wall -fno-strength-reduce
+# -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE
 LDFLAGS= -s
 
 # Look where your install program is.
-INSTALL = /usr/bin/install
-BINDIR = /usr/sbin
-MANDIR = /usr/man
+INSTALL = /System/Tools/install
+
+# Destination paths, set prefix=/opt if required
+BINDIR = $(prefix)/bin
+MANDIR = $(prefix)/usr/share/man
 
 # There is one report that under an all ELF system there may be a need to
 # explicilty link with libresolv.a.  If linking syslogd fails you may wish
@@ -34,8 +37,9 @@
 # The following define establishes ownership for the man pages.
 # Avery tells me that there is a difference between Debian and
 # Slackware.  Rather than choose sides I am leaving it up to the user.
-MAN_OWNER = root
-# MAN_OWNER = man
+MAN_USER = root
+MAN_GROUP = root
+MAN_PERMS = 644
 
 # The following define establishes the name of the pid file for the
 # syslogd daemon.  The library include file (paths.h) defines the
@@ -116,7 +120,7 @@
 	${INSTALL} -m 500 -s klogd ${BINDIR}/klogd
 
 install_man:
-	${INSTALL} -o ${MAN_OWNER} -g ${MAN_OWNER} -m 644 sysklogd.8 ${MANDIR}/man8/sysklogd.8
-	${INSTALL} -o ${MAN_OWNER} -g ${MAN_OWNER} -m 644 syslogd.8 ${MANDIR}/man8/syslogd.8
-	${INSTALL} -o ${MAN_OWNER} -g ${MAN_OWNER} -m 644 syslog.conf.5 ${MANDIR}/man5/syslog.conf.5
-	${INSTALL} -o ${MAN_OWNER} -g ${MAN_OWNER} -m 644 klogd.8 ${MANDIR}/man8/klogd.8
+	${INSTALL} -o ${MAN_USER} -g ${MAN_GROUP} -m ${MAN_PERMS} sysklogd.8 ${MANDIR}/man8/sysklogd.8
+	${INSTALL} -o ${MAN_USER} -g ${MAN_GROUP} -m ${MAN_PERMS} syslogd.8 ${MANDIR}/man8/syslogd.8
+	${INSTALL} -o ${MAN_USER} -g ${MAN_GROUP} -m ${MAN_PERMS} syslog.conf.5 ${MANDIR}/man5/syslog.conf.5
+	${INSTALL} -o ${MAN_USER} -g ${MAN_GROUP} -m ${MAN_PERMS} klogd.8 ${MANDIR}/man8/klogd.8
diff -urN sysklogd-1.4.1/NEWS sysklogd-1.4.1-STEP/NEWS
--- sysklogd-1.4.1/NEWS	2000-09-18 07:44:52.000000000 +1200
+++ sysklogd-1.4.1-STEP/NEWS	2006-04-25 06:07:13.482705608 +1200
@@ -59,7 +59,7 @@
 
 klogd ---------------------------------------------------------------------
 Error checking and reporting enhanced.  I have a couple of reports
-that klogd is experiencing errors when reading the /proc filesystem.
+that klogd is experiencing errors when reading the /System/Processes filesystem.
 Any additional information would be appreciated.
 
 The sys_syslog function has been renamed to ksyslog.  This was in a
@@ -130,14 +130,14 @@
 Modified signal handling in klogd so that all signal are set to ignored
 before establishing specific signal handlers.
 
-Fixed bug in syslogd which was causing a delay in opening of the /dev/log
+Fixed bug in syslogd which was causing a delay in opening of the /System/Devices/log
 UNIX domain socket.  This should correct the race condition which was
 preventing klogd from properly logging kernel messages when the two
 daemons were started in rapid succession.
 
 Modified the closing/opening of file descriptors when syslogd was
 compiled with auto-backgrounding support.  Closes the potential for
-a somewhat obscure bug caused by the /dev/log socket being opened on
+a somewhat obscure bug caused by the /System/Devices/log socket being opened on
 fd 0.
 
 Changed the names of the man pages from an extension of 1 to 8.
diff -urN sysklogd-1.4.1/README.1st sysklogd-1.4.1-STEP/README.1st
--- sysklogd-1.4.1/README.1st	1997-06-03 05:21:39.000000000 +1200
+++ sysklogd-1.4.1-STEP/README.1st	2006-04-25 06:07:13.483705456 +1200
@@ -1,5 +1,5 @@
-Very important information before using version 1.3
----------------------------------------------------
+Important information
+---------------------
 
 The included version of syslogd behaves in a slightly different manner
 to the one in former releases.  Please review the following important
@@ -60,6 +60,13 @@
   The cleanest solution to this problem is to insure that the system
   configuration scripts (rc.*) provide a clean working environment for
   a freshly booted system.  As part of the initialization process
-  these scripts should remove all old .pid files found in /var/run.
+  these scripts should remove all old .pid files found in /System/ApplicationData/RuntimeData.
   This will insure that klogd and syslogd start properly even if prior
   executions have been terminated harshly.
+
+* Large file support, i.e. support to write to log files that are
+  larger than 2 GB is not part of syslogd, but a matter of the Glibc
+  emitting different system calls to the kernel interface.  To support
+  large files you'll have to compile syslogd with the compiler defines
+  -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE so that glibc adjusts the
+  system calls.
diff -urN sysklogd-1.4.1/README.linux sysklogd-1.4.1-STEP/README.linux
--- sysklogd-1.4.1/README.linux	1999-01-19 13:09:12.000000000 +1300
+++ sysklogd-1.4.1-STEP/README.linux	2006-04-25 06:07:13.484705304 +1200
@@ -40,12 +40,17 @@
 a useful addition to the software gene pool.
 
 There is a mailing list covering this package and syslog in general.
-The lists address is sysklogd@Infodrom.North.DE .  To subscribe send a
-mail to Majordomo@Infodrom.North.DE with a line "subscribe sysklogd"
+The lists address is infodrom-sysklogd@lists.infodrom.org .  To subscribe send a
+mail to majordomo@lists.infodrom.org with a line "subscribe infodrom-sysklogd"
 in the message body.
 
-New versions of this package will be available at Joey's ftp server.
-ftp://ftp.infodrom.north.de/pub/people/joey/sysklogd/
+A second mailing list exists as infodrom-sysklogd-cvs@lists.infodrom.org.  Only
+CVS messages and diffs are distributed there. Whenever new code is added to
+sysklogd, CVS generates a mail from these changes which will be sent to
+this list.  Discussions will take place on the first list.
+
+The latest version of this software can be found at:
+http://www.infodrom.org/projects/sysklogd/download.php3
 
 Best regards,
 
@@ -67,6 +72,6 @@
 
 Martin Schulze
 Infodrom Oldenburg
-joey@linux.de
+joey@infodrom.org
 
-And a host of bug reporters whose contributions cannot be underestimated.
+And a number of bug reporters whose contributions cannot be underestimated.
diff -urN sysklogd-1.4.1/klogd.8 sysklogd-1.4.1-STEP/klogd.8
--- sysklogd-1.4.1/klogd.8	2001-03-12 08:35:51.000000000 +1300
+++ sysklogd-1.4.1-STEP/klogd.8	2006-04-25 06:07:13.515700592 +1200
@@ -97,14 +97,14 @@
 offers a cleaner separation of services.
 
 In Linux there are two potential sources of kernel log information: the 
-.I /proc
+.I /System/Processes
 file system and the syscall (sys_syslog) interface, although
 ultimately they are one and the same.  Klogd is designed to choose
 whichever source of information is the most appropriate.  It does this
 by first checking for the presence of a mounted 
-.I /proc
+.I /System/Processes
 file system.  If this is found the 
-.I /proc/kmsg
+.I /System/Processes/kmsg
 file is used as the source of kernel log
 information.  If the proc file system is not mounted 
 .B klogd
@@ -238,7 +238,7 @@
 following filenames will be tried:
 
 .nf
-.I /boot/System.map
+.I /System/Boot/System.map
 .I /System.map
 .I /usr/src/linux/System.map
 .fi
@@ -249,10 +249,10 @@
 provides support for both production and experimental kernels.
 
 For example a production kernel may have its map file stored in
-/boot/System.map.  If an experimental or test kernel is compiled with
+/System/Boot/System.map.  If an experimental or test kernel is compiled with
 the sources in the 'standard' location of /usr/src/linux the system
 map will be found in /usr/src/linux/System.map.  When klogd starts
-under the experimental kernel the map in /boot/System.map will be
+under the experimental kernel the map in /System/Boot/System.map will be
 bypassed in favor of the map in /usr/src/linux/System.map.
 
 Modern kernels as of 1.3.43 properly format important kernel addresses
@@ -321,7 +321,7 @@
 .B klogd
 to reload the module symbol information whenever a protection fault
 is detected.  Caution should be used before invoking the program in
-\'paranoid\' mode.  The stability of the kernel and the operating
+\&'paranoid\&' mode.  The stability of the kernel and the operating
 environment is always under question when a protection fault occurs.
 Since the klogd daemon must execute system calls in order to read the
 module symbol information there is the possibility that the system may
@@ -363,14 +363,14 @@
 and re-choose an input source.  Using
 .BR SIGSTOP " and " SIGCONT
 in combination the kernel log input can be re-chosen without stopping and
-restarting the daemon.  For example if the \fI/proc\fR file system is to be
+restarting the daemon.  For example if the \fI/System/Processes\fR file system is to be
 un-mounted the following command sequence should be used:
 .PP
 .PD 0
 .TP
 	# kill -TSTP pid
 .TP
-	# umount /proc
+	# umount /System/Processes
 .TP
 	# kill -CONT pid
 .PD
@@ -403,15 +403,15 @@
 .SH FILES
 .PD 0
 .TP
-.I /proc/kmsg
+.I /System/Processes/kmsg
 One Source for kernel messages
 .B klogd
 .TP
-.I /var/run/klogd.pid
+.I /System/ApplicationData/RuntimeData/klogd.pid
 The file containing the process id of 
 .B klogd
 .TP
-.I /boot/System.map, /System.map, /usr/src/linux/System.map
+.I /System/Boot/System.map, /System.map, /usr/src/linux/System.map
 Default locations for kernel system maps.
 .PD
 .SH BUGS
diff -urN sysklogd-1.4.1/klogd.c sysklogd-1.4.1-STEP/klogd.c
--- sysklogd-1.4.1/klogd.c	2001-03-12 08:40:10.000000000 +1300
+++ sysklogd-1.4.1-STEP/klogd.c	2006-04-25 06:13:32.525082408 +1200
@@ -64,7 +64,7 @@
  *
  *		The -s switch causes the program to use the syscall
  *		interface to the kernel message facility.  This can be
- *		used to override the presence of the /proc filesystem.
+ *		used to override the presence of the /System/Processes filesystem.
  *
  *		The -o switch causes the program to operate in 'one-shot'
  *		mode.  A single call will be made to read the complete
@@ -243,6 +243,9 @@
  *	people have submitted patches: Troels Walsted Hansen
  *	<troels@thule.no>, Wolfgang Oertl <Wolfgang.Oertl@uibk.ac.at>
  *	and Thomas Roessler.
+ * Thu Apr 29 15:24:07 2004: Solar Designer <solar@openwall.com>
+ *	Prevent potential buffer overflow in reading messages from the
+ *	kernel log rinbuffer.
  */
 
 
@@ -282,7 +285,7 @@
 #if defined(FSSTND)
 static char	*PidFile = _PATH_VARRUN "klogd.pid";
 #else
-static char	*PidFile = "/etc/klogd.pid";
+static char	*PidFile = "/System/ApplicationData/RuntimeData/klogd.pid";
 #endif
 #endif
 
@@ -938,7 +941,7 @@
 	 * messages into this fresh buffer.
 	 */
 	memset(log_buffer, '\0', sizeof(log_buffer));
-	if ( (rdcnt = ksyslog(2, log_buffer, sizeof(log_buffer))) < 0 )
+	if ( (rdcnt = ksyslog(2, log_buffer, sizeof(log_buffer)-1)) < 0 )
 	{
 		if ( errno == EINTR )
 			return;
diff -urN sysklogd-1.4.1/ksym.c sysklogd-1.4.1-STEP/ksym.c
--- sysklogd-1.4.1/ksym.c	2000-09-13 09:53:31.000000000 +1200
+++ sysklogd-1.4.1-STEP/ksym.c	2006-04-25 06:07:17.676068120 +1200
@@ -42,7 +42,7 @@
  *	message is issued and translation is disabled.
  *
  * Wed Dec  6 16:14:11 CST 1995:  Dr. Wettstein
- *	Added /boot/System.map to the list of symbol maps to search for.
+ *	Added /System/Boot/System.map to the list of symbol maps to search for.
  *	Also made this map the first item in the search list.  I am open
  *	to CONSTRUCTIVE suggestions for any additions or corrections to
  *	the list of symbol maps to search for.  Be forewarned that the
@@ -55,7 +55,7 @@
  *	Added support for searching of the list of symbol maps.  This
  *	allows support for access to multiple symbol maps.  The theory
  *	behind this is that a production kernel may have a system map in
- *	/boot/System.map.  If a test kernel is booted this system map
+ *	/System/Boot/System.map.  If a test kernel is booted this system map
  *	would be skipped in favor of one found in /usr/src/linux.
  *
  * Thu Jan 18 11:18:31 CST 1996:  Dr. Wettstein
@@ -105,6 +105,15 @@
  *
  * Tue Sep 12 23:48:12 CEST 2000: Martin Schulze <joey@infodrom.ffis.de>
  *	Close symbol file in InitKsyms() when an error occurred.
+ *
+ * Thu Apr 29 18:07:16 CEST 2004: Dmitry Levin <ldv@altlinux.org>
+ *	Close file descriptor in FindSymbolFile() in order not to leak
+ *	file descriptors.
+ *
+ * Fri Jul 16 08:32:49 CEST 2004: Ulf Härnhammar <Ulf.Harnhammar.9485@student.uu.se>
+ *	Added boundary check for fscanf() in InitKsyms() and
+ *	CheckMapVersion() to prevent an unintended crash when reading
+ *	an incorrect System.map.
  */
 
 
@@ -132,7 +141,7 @@
 
 static char *system_maps[] =
 {
-	"/boot/System.map",
+	"/System/Boot/System.map",
 	"/System.map",
 #if defined(TEST)
 	"./System.map",
@@ -236,7 +245,7 @@
 	 */
 	while ( !feof(sym_file) )
 	{
-		if ( fscanf(sym_file, "%lx %c %s\n", &address, &type, sym)
+		if ( fscanf(sym_file, "%lx %c %511s\n", &address, &type, sym)
 		    != 3 )
 		{
 			Syslog(LOG_ERR, "Error in symbol table input (#1).");
@@ -299,8 +308,8 @@
  *		This strategy allows klogd to locate valid symbol files
  *		for both a production and an experimental kernel.  For
  *		example a map for a production kernel could be installed
- *		in /boot.  If an experimental kernel is loaded the map
- *		in /boot will be skipped and the map in /usr/src/linux would
+ *		in /System/Boot.  If an experimental kernel is loaded the map
+ *		in /System/Boot will be skipped and the map in /usr/src/linux would
  *		be used if its version number matches the executing kernel.
  *
  * Arguements:	None specified.
@@ -344,6 +353,7 @@
 		if ( (sym_file = fopen(symfile, "r")) != (FILE *) 0 ) {
 			if (CheckMapVersion(symfile) == 1)
 				file = symfile;
+			fclose (sym_file);
 		}
 		if (sym_file == (FILE *) 0 || file == (char *) 0) {
 			sprintf (symfile, "%s", *mf);
@@ -352,6 +362,7 @@
 			if ( (sym_file = fopen(symfile, "r")) != (FILE *) 0 ) {
 				if (CheckMapVersion(symfile) == 1)
 					file = symfile;
+				fclose (sym_file);
 			}
 		}
 
@@ -533,7 +544,7 @@
 		version = 0;
 		while ( !feof(sym_file) && (version == 0) )
 		{
-			if ( fscanf(sym_file, "%lx %c %s\n", &address, \
+			if ( fscanf(sym_file, "%lx %c %511s\n", &address, \
 				    &type, sym) != 3 )
 			{
 				Syslog(LOG_ERR, "Error in symbol table input (#2).");
@@ -899,3 +910,11 @@
 	return;
 }
 #endif
+
+/*
+ * Local variables:
+ *  c-indent-level: 8
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ * End:
+ */
diff -urN sysklogd-1.4.1/ksym_mod.c sysklogd-1.4.1-STEP/ksym_mod.c
--- sysklogd-1.4.1/ksym_mod.c	2000-09-13 09:15:28.000000000 +1200
+++ sysklogd-1.4.1-STEP/ksym_mod.c	2006-04-25 06:07:17.682067208 +1200
@@ -72,12 +72,17 @@
  *	file, by submission from Mark Simon Phillips <M.S.Phillips@nortel.co.uk>.
  *
  * Sun Jan  3 18:38:03 CET 1999: Martin Schulze <joey@infodrom.north.de>
- *	Corrected return value of AddModule if /dev/kmem can't be
- *	loaded.  This will prevent klogd from segfaulting if /dev/kmem
+ *	Corrected return value of AddModule if /System/Devices/kmem can't be
+ *	loaded.  This will prevent klogd from segfaulting if /System/Devices/kmem
  *	is not available.  Patch from Topi Miettinen <tom@medialab.sonera.net>.
  *
  * Tue Sep 12 23:11:13 CEST 2000: Martin Schulze <joey@infodrom.ffis.de>
  *	Changed llseek() to lseek64() in order to skip a libc warning.
+ *
+ * Wed Mar 31 17:35:01 CEST 2004: Martin Schulze <joey@infodrom.org>
+ *	Removed references to <linux/module.h> since it doesn't work
+ *	anymore with its recent content from Linux 2.4/2.6, created
+ *	module.h locally instead.
  */
 
 
@@ -89,11 +94,12 @@
 #include <errno.h>
 #include <sys/fcntl.h>
 #include <sys/stat.h>
+#include "module.h"
 #if !defined(__GLIBC__)
 #include <linux/time.h>
-#include <linux/module.h>
+#include <linux/linkage.h>
 #else /* __GLIBC__ */
-#include <linux/module.h>
+#include <linux/linkage.h>
 extern __off64_t lseek64 __P ((int __fd, __off64_t __offset, int __whence));
 extern int get_kernel_syms __P ((struct kernel_sym *__table));
 #endif /* __GLIBC__ */
@@ -107,7 +113,7 @@
 
 #if !defined(__GLIBC__)
 /*
- * The following bit uses some kernel/library magic to product what
+ * The following bit uses some kernel/library magic to produce what
  * looks like a function call to user level code.  This function is
  * actually a system call in disguise.  The purpose of the getsyms
  * call is to return a current copy of the in-kernel symbol table.
@@ -398,14 +404,14 @@
 		}
 		mp = &sym_array_modules[num_modules];
 
-		if ( (memfd = open("/dev/kmem", O_RDONLY)) < 0 )
+		if ( (memfd = open("/System/Devices/kmem", O_RDONLY)) < 0 )
 		{
-			Syslog(LOG_WARNING, "Error opening /dev/kmem\n");
+			Syslog(LOG_WARNING, "Error opening /System/Devices/kmem\n");
 			return(0);
 		}
 		if ( lseek64(memfd, address, SEEK_SET) < 0 )
 		{
-			Syslog(LOG_WARNING, "Error seeking in /dev/kmem\n");
+			Syslog(LOG_WARNING, "Error seeking in /System/Devices/kmem\n");
 			Syslog(LOG_WARNING, "Symbol %s, value %08x\n", symbol, address);
 			return(0);
 		}
diff -urN sysklogd-1.4.1/module.h sysklogd-1.4.1-STEP/module.h
--- sysklogd-1.4.1/module.h	1970-01-01 12:00:00.000000000 +1200
+++ sysklogd-1.4.1-STEP/module.h	2006-04-25 06:07:27.282607704 +1200
@@ -0,0 +1,90 @@
+/*
+    module.h - Miscellaneous module definitions
+    Copyright (c) 1996 Richard Henderson <rth@tamu.edu>
+    Copyright (c) 2004 Martin Schulze <joey@infodrom.org>
+
+    This file is part of the sysklogd package.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+/* ChangeLog:
+ *
+ * Wed Mar 31 17:35:01 CEST 2004: Martin Schulze <joey@infodrom.org>
+ *	Created local copy of module.h based on the content of Linux
+ *	2.2 since <linux/module.h> doesn't work anymore with its
+ *	recent content from Linux 2.4/2.6.
+ */
+
+#include <asm/atomic.h>
+
+#define MODULE_NAME_LEN 60
+
+struct kernel_sym
+{
+	unsigned long value;
+	char name[MODULE_NAME_LEN];
+};
+
+
+struct list_head {
+	struct list_head *next, *prev;
+};
+
+
+struct module_info
+{
+	unsigned long addr;
+	unsigned long size;
+	unsigned long flags;
+	long usecount;
+};
+
+
+struct module
+{
+	unsigned long size_of_struct;	/* == sizeof(module) */
+	struct module *next;
+	const char *name;
+	unsigned long size;
+
+	union
+	{
+		int usecount;
+		long pad;
+	} uc;				/* Needs to keep its size - so says rth */
+
+	unsigned long flags;		/* AUTOCLEAN et al */
+
+	unsigned nsyms;
+	unsigned ndeps;
+
+	struct module_symbol *syms;
+	struct module_ref *deps;
+	struct module_ref *refs;
+	int (*init)(void);
+	void (*cleanup)(void);
+	const struct exception_table_entry *ex_table_start;
+	const struct exception_table_entry *ex_table_end;
+#ifdef __alpha__
+	unsigned long gp;
+#endif
+	/* Members past this point are extensions to the basic
+	   module support and are optional.  Use mod_opt_member()
+	   to examine them.  */
+	const struct module_persist *persist_start;
+	const struct module_persist *persist_end;
+	int (*can_unload)(void);
+};
diff -urN sysklogd-1.4.1/pidfile.c sysklogd-1.4.1-STEP/pidfile.c
--- sysklogd-1.4.1/pidfile.c	1998-02-11 11:37:12.000000000 +1300
+++ sysklogd-1.4.1-STEP/pidfile.c	2006-04-25 06:07:17.687066448 +1200
@@ -53,7 +53,7 @@
 /* check_pid
  *
  * Reads the pid using read_pid and looks up the pid in the process
- * table (using /proc) to determine if the process already exists. If
+ * table (using /System/Processes) to determine if the process already exists. If
  * so 1 is returned, otherwise 0.
  */
 int check_pid (char *pidfile)
@@ -87,7 +87,7 @@
   int fd;
   int pid;
 
-  if ( ((fd = open(pidfile, O_RDWR|O_CREAT, 0644)) == -1)
+  if ( ((fd = open(pidfile, O_RDWR|O_CREAT|O_TRUNC, 0644)) == -1)
        || ((f = fdopen(fd, "r+")) == NULL) ) {
       fprintf(stderr, "Can't open or create %s.\n", pidfile);
       return 0;
diff -urN sysklogd-1.4.1/pidfile.h sysklogd-1.4.1-STEP/pidfile.h
--- sysklogd-1.4.1/pidfile.h	1998-02-11 11:37:13.000000000 +1300
+++ sysklogd-1.4.1-STEP/pidfile.h	2006-04-25 06:07:17.687066448 +1200
@@ -30,7 +30,7 @@
 /* check_pid
  *
  * Reads the pid using read_pid and looks up the pid in the process
- * table (using /proc) to determine if the process already exists. If
+ * table (using /System/Processes) to determine if the process already exists. If
  * so 1 is returned, otherwise 0.
  */
 int check_pid (char *pidfile);
diff -urN sysklogd-1.4.1/sysklogd.8 sysklogd-1.4.1-STEP/sysklogd.8
--- sysklogd-1.4.1/sysklogd.8	2001-03-12 08:35:51.000000000 +1300
+++ sysklogd-1.4.1-STEP/sysklogd.8	2006-04-25 06:07:22.504334112 +1200
@@ -84,7 +84,7 @@
 .B MAXFUNIX
 within the syslogd.c source file.  An example for a chroot() daemon is
 described by the people from OpenBSD at
-http://www.psionic.com/papers/dns.html.
+<http://www.guides.sk/psionic/dns/>.
 .TP
 .B "\-d"
 Turns on debug mode.  Using this the daemon will not proceed a 
@@ -117,7 +117,8 @@
 between two \fI-- MARK --\fR lines is 20 minutes.  This can be changed
 with this option.  Setting the
 .I interval
-to zero turns it off entirely.
+to zero turns it off entirely.  Depending on other log messages
+generated these lines may not be written consecutively.
 .TP
 .B "\-n"
 Avoid auto-backgrounding.  This is needed especially if the
@@ -127,7 +128,7 @@
 .TP
 .BI "\-p " "socket"
 You can specify an alternative unix domain socket instead of
-.IR /dev/log "."
+.IR /System/Devices/log "."
 .TP
 .B "\-r"
 This option will enable the facility to receive message from the
@@ -160,7 +161,7 @@
 using the following:
 .IP
 .nf
-kill -SIGNAL `cat /var/run/syslogd.pid`
+kill -SIGNAL `cat /System/ApplicationData/RuntimeData/syslogd.pid`
 .fi
 .PP
 .TP
@@ -364,8 +365,10 @@
 
 To avoid this in further times no messages that were received from a
 remote host are sent out to another (or the same) remote host
-anymore.  If there are scenarios where this doesn't make sense, please
-drop me (Joey) a line.
+anymore.  If you experience are setup in which this doesn't make
+sense, please use the
+.B \-h
+commandline switch.
 
 If the remote host is located in the same domain as the host, 
 .B syslogd
@@ -418,7 +421,7 @@
 syslog function in the shared libraries changed somewhere in the
 region of libc.so.4.[2-4].n.  The specific change was to
 null-terminate the message before transmitting it to the 
-.I /dev/log
+.I /System/Devices/log
 socket.  Proper functioning of this version of syslogd is dependent on
 null-termination of the message.
 
@@ -524,10 +527,10 @@
 .BR syslog.conf (5)
 for exact information.
 .TP
-.I /dev/log
+.I /System/Devices/log
 The Unix domain socket to from where local syslog messages are read.
 .TP
-.I /var/run/syslogd.pid
+.I /System/ApplicationData/RuntimeData/syslogd.pid
 The file containing the process id of 
 .BR syslogd .
 .PD
diff -urN sysklogd-1.4.1/syslog.c sysklogd-1.4.1-STEP/syslog.c
--- sysklogd-1.4.1/syslog.c	2001-03-12 08:35:51.000000000 +1300
+++ sysklogd-1.4.1-STEP/syslog.c	2006-04-25 06:07:22.507333656 +1200
@@ -47,6 +47,9 @@
  * Sun Mar 11 20:23:44 CET 2001: Martin Schulze <joey@infodrom.ffis.de>
  *	Use SOCK_DGRAM for loggin, renables it to work.	
  *
+ * Wed Aug 27 17:48:16 CEST 2003: Martin Schulze <joey@Infodrom.org>
+ *	Improved patch by Michael Pomraning <mjp@securepipe.com> to
+ *	reconnect klogd to the logger after it went away.
  */
 
 #include <sys/types.h>
@@ -70,7 +73,7 @@
 #include <paths.h>
 #include <stdio.h>
 
-#define	_PATH_LOGNAME	"/dev/log"
+#define	_PATH_LOGNAME	"/System/Devices/log"
 
 static int	LogFile = -1;		/* fd for log */
 static int	connected;		/* have done connect */
@@ -98,6 +101,7 @@
 	register char *p;
 	time_t now;
 	int fd, saved_errno;
+	int result;
 	char tbuf[2048], fmt_cpy[1024], *stdp = (char *) 0;
 
 	saved_errno = errno;
@@ -167,7 +171,16 @@
 	}
 
 	/* output the message to the local logger */
-	if (write(LogFile, tbuf, cnt + 1) >= 0 || !(LogStat&LOG_CONS))
+	result = write(LogFile, tbuf, cnt + 1);
+
+	if (result == -1
+	    && (errno == ECONNRESET || errno == ENOTCONN || errno == ECONNREFUSED)) {
+		closelog();
+		openlog(LogTag, LogStat | LOG_NDELAY, LogFacility);
+		result = write(LogFile, tbuf, cnt + 1);
+	}
+
+	if (result >= 0 || !(LogStat&LOG_CONS))
 		return;
 
 	/*
diff -urN sysklogd-1.4.1/syslog.conf sysklogd-1.4.1-STEP/syslog.conf
--- sysklogd-1.4.1/syslog.conf	1997-06-03 05:42:32.000000000 +1200
+++ sysklogd-1.4.1-STEP/syslog.conf	2006-04-25 06:07:22.508333504 +1200
@@ -7,29 +7,29 @@
 
 # Store critical stuff in critical
 #
-*.=crit;kern.none               /var/adm/critical
+*.=crit;kern.none               /System/ApplicationData/adm/critical
 
 # Kernel messages are first, stored in the kernel file, 
 # critical messages and higher ones also go to another
 # host and to the console
 #
-kern.*				/var/adm/kernel
+kern.*				/System/ApplicationData/adm/kernel
 kern.crit			@finlandia
-kern.crit			/dev/console
-kern.info;kern.!err		/var/adm/kernel-info
+kern.crit			/System/Devices/console
+kern.info;kern.!err		/System/ApplicationData/adm/kernel-info
 
 # The tcp wrapper loggs with mail.info, we display all
 # the connections on tty12
 #
-mail.=info			/dev/tty12
+mail.=info			/System/Devices/tty12
 
 # Store all mail concearning stuff in a file
 #
-mail.*;mail.!=info		-/var/adm/mail
+mail.*;mail.!=info		-/System/ApplicationData/adm/mail
 
 # Log all mail.info and news.info messages to info
 #
-mail,news.=info			-/var/adm/info
+mail,news.=info			-/System/ApplicationData/adm/info
 
 # Log info and notice mesages to messages file
 #
diff -urN sysklogd-1.4.1/syslog.conf.5 sysklogd-1.4.1-STEP/syslog.conf.5
--- sysklogd-1.4.1/syslog.conf.5	1999-08-21 22:49:14.000000000 +1200
+++ sysklogd-1.4.1-STEP/syslog.conf.5	2006-04-25 06:07:22.512332896 +1200
@@ -64,7 +64,7 @@
 The
 .I facility
 is one of the following keywords:
-.BR auth ", " authpriv ", " cron ", " daemon ", " kern ", " lpr ", "
+.BR auth ", " authpriv ", " cron ", " daemon ", " ftp ", " kern ", " lpr ", "
 .BR mail ", " mark ", " news ", " security " (same as " auth "), "
 .BR syslog ", " user ", " uucp " and " local0 " through " local7 .
 The keyword 
@@ -121,12 +121,21 @@
 
 This 
 .BR syslogd (8)
-has a syntax extension to the original BSD source, that makes its use
+has a syntax extension to the original BSD source, which makes its use
 more intuitively.  You may precede every priority with an equation sign
-(``='') to specify only this single priority and not any of the
-above.  You may also (both is valid, too) precede the priority with an
-exclamation mark (``!'') to ignore all that priorities, either exact
-this one or this and any higher priority.  If you use both extensions
+(``='') to specify that
+.B syslogd
+should only refer to this single priority and not this priority and
+all higher priorities.
+
+You may also precide the priority with an exclamation mark (``!'') if
+you want
+.B syslogd
+to ignore this priority and all higher priorities.
+You may even use both, the exclamation mark and the equation sign if
+you want
+.B syslogd
+to ignore only this single priority.  If you use both extensions
 than the exclamation mark must occur before the equation sign, just
 use it intuitively.
 
@@ -162,7 +171,7 @@
 .SS Terminal and Console
 If the file you specified is a tty, special tty-handling is done, same
 with
-.IR /dev/console .
+.IR /System/Devices/console .
 
 .SS Remote Machine
 This 
@@ -202,13 +211,13 @@
 .nf
 # Store critical stuff in critical
 #
-*.=crit;kern.none            /var/adm/critical
+*.=crit;kern.none            /System/ApplicationData/adm/critical
 .fi
 .LP
 This will store all messages with the priority
 .B crit
 in the file
-.IR /var/adm/critical ,
+.IR /System/ApplicationData/adm/critical ,
 except for any kernel message.
 
 .IP
@@ -217,15 +226,15 @@
 # file, critical messages and higher ones also go
 # to another host and to the console
 #
-kern.*                       /var/adm/kernel
+kern.*                       /System/ApplicationData/adm/kernel
 kern.crit                    @finlandia
-kern.crit                    /dev/console
-kern.info;kern.!err          /var/adm/kernel-info
+kern.crit                    /System/Devices/console
+kern.info;kern.!err          /System/ApplicationData/adm/kernel-info
 .fi
 .LP
 The first rule direct any message that has the kernel facility to the
 file
-.IR /var/adm/kernel .
+.IR /System/ApplicationData/adm/kernel .
 
 The second statement directs all kernel messages of the priority
 .B crit
@@ -241,7 +250,7 @@
 come with priorities from
 .BR info " up to " warning
 in the file
-.IR /var/adm/kernel-info .
+.IR /System/ApplicationData/adm/kernel-info .
 Everything from
 .I err
 and higher is excluded.
@@ -251,13 +260,13 @@
 # The tcp wrapper loggs with mail.info, we display
 # all the connections on tty12
 #
-mail.=info                   /dev/tty12
+mail.=info                   /System/Devices/tty12
 .fi
 .LP
 This directs all messages that uses 
 .BR mail.info " (in source " LOG_MAIL " | " LOG_INFO )
 to
-.IR /dev/tty12 , 
+.IR /System/Devices/tty12 , 
 the 12th console.  For example the tcpwrapper
 .BR tcpd (8)
 uses this as it's default.
@@ -266,7 +275,7 @@
 .nf
 # Store all mail concerning stuff in a file
 #
-mail.*;mail.!=info           /var/adm/mail
+mail.*;mail.!=info           /System/ApplicationData/adm/mail
 .fi
 .LP
 This pattern matches all messages that come with the
@@ -274,34 +283,34 @@
 facility, except for the
 .B info
 priority.  These will be stored in the file
-.IR /var/adm/mail .
+.IR /System/ApplicationData/adm/mail .
 
 .IP
 .nf
 # Log all mail.info and news.info messages to info
 #
-mail,news.=info              /var/adm/info
+mail,news.=info              /System/ApplicationData/adm/info
 .fi
 .LP
 This will extract all messages that come either with
 .BR mail.info " or with " news.info 
 and store them in the file
-.IR /var/adm/info .
+.IR /System/ApplicationData/adm/info .
 
 .IP
 .nf
 # Log info and notice messages to messages file
 #
 *.=info;*.=notice;\\
-	mail.none  /var/log/messages
+	mail.none  /System/ApplicationData/log/messages
 .fi
 .LP
 This lets the
 .B syslogd
 log all messages that come with either the
 .BR info " or the " notice
-facility into the file
-.IR /var/log/messages ,
+priority into the file
+.IR /System/ApplicationData/log/messages ,
 except for all messages that use the
 .B mail
 facility.
@@ -311,7 +320,7 @@
 # Log info messages to messages file
 #
 *.=info;\\
-	mail,news.none       /var/log/messages
+	mail,news.none       /System/ApplicationData/log/messages
 .fi
 .LP
 This statement causes the
@@ -319,7 +328,7 @@
 to log all messages that come with the
 .B info
 priority to the file
-.IR /var/log/messages .
+.IR /System/ApplicationData/log/messages .
 But any message coming either with the
 .BR mail " or the " news
 facility will not be stored.
diff -urN sysklogd-1.4.1/syslogd.c sysklogd-1.4.1-STEP/syslogd.c
--- sysklogd-1.4.1/syslogd.c	2001-03-12 08:40:10.000000000 +1300
+++ sysklogd-1.4.1-STEP/syslogd.c	2006-04-25 06:12:39.715110744 +1200
@@ -392,7 +392,7 @@
  * Mon Oct 12 20:22:59 CEST 1998: Martin Schulze <joey@infodrom.north.de>
  *	Added support for setutent()/getutent()/endutend() instead of
  *	binary reading the UTMP file.  This is the the most portable
- *	way.  This allows /var/run/utmp format to change, even to a
+ *	way.  This allows /System/ApplicationData/RuntimeData/utmp format to change, even to a
  *	real database or utmp daemon. Also if utmp file locking is
  *	implemented in libc, syslog will use it immediately.  Thanks
  *	to Topi Miettinen <tom@medialab.sonera.net>.
@@ -441,6 +441,39 @@
  *	Don't return a closed fd if `-a' is called with a wrong path.
  *	Thanks to Bill Nottingham <notting@redhat.com> for providing
  *	a patch.
+ * Thu Apr 13 05:08:10 CEST 2001: Jon Burgess <Jon_Burgess@eur.3com.com>
+ *	Moved the installation of the signal handler up a little bit
+ *	so it guaranteed to be available when the child is forked,
+ *	hence, fixing a  race condition.  This used to create problems
+ *	with UML and fast machines.
+ *
+ * Sat Apr 17 18:03:05 CEST 2004: Steve Grubb <linux_4ever@yahoo.com>
+ *	Correct memory allocation for for commandline arguments in
+ *	crunch_list().
+ *
+ * Thu Apr 29 12:38:39 CEST 2004: Solar Designer <solar@openwall.com>
+ *	Applied Openwall paranoia patches to improve crunch_list().
+ *
+ * Tue May  4 16:47:30 CEST 2004: Solar Designer <solar@openwall.com>
+ *	Ensure that "len" is not placed in a register, and that the
+ *	endtty() signal handler is not installed too early which could
+ *	cause a segmentation fault or worse.
+ *
+ * Tue May  4 16:52:01 CEST 2004: Solar Designer <solar@openwall.com>
+ *	Adjust the size of a variable to prevent a buffer overflow
+ *	should _PATH_DEV ever contain something different than "/System/Devices/".
+ *
+ * Tue Nov  2 20:28:23 CET 2004: Colin Phipps <cph@cph.demon.co.uk>
+ *	Don't block on the network socket, in case a packet gets lost
+ *	between select and recv.
+ *
+ * Sun Nov  7 12:28:47 CET 2004: Martin Schulze <joey@infodrom.org>
+ *	Discard any timestamp information found in received syslog
+ *	messages.  This will affect local messages sent from a
+ *	different timezone.
+ *
+ * Sun Nov  7 13:47:00 CET 2004: Martin Schulze <joey@infodrom.org>
+ *	Remove trailing newline when forwarding messages.
  */
 
 
@@ -507,13 +540,13 @@
 #ifdef _PATH_UTMP
 #define UTMP_FILE _PATH_UTMP
 #else
-#define UTMP_FILE "/etc/utmp"
+#define UTMP_FILE "/System/ApplicationData/RuntimeData/utmp"
 #endif
 #endif
 #endif
 
 #ifndef _PATH_LOGCONF 
-#define _PATH_LOGCONF	"/etc/syslog.conf"
+#define _PATH_LOGCONF	"/System/Settings/syslog.conf"
 #endif
 
 #if defined(SYSLOGD_PIDNAME)
@@ -521,32 +554,32 @@
 #if defined(FSSTND)
 #define _PATH_LOGPID _PATH_VARRUN SYSLOGD_PIDNAME
 #else
-#define _PATH_LOGPID "/etc/" SYSLOGD_PIDNAME
+#define _PATH_LOGPID "/System/ApplicationData/RuntimeData/" SYSLOGD_PIDNAME
 #endif
 #else
 #ifndef _PATH_LOGPID
 #if defined(FSSTND)
 #define _PATH_LOGPID _PATH_VARRUN "syslogd.pid"
 #else
-#define _PATH_LOGPID "/etc/syslogd.pid"
+#define _PATH_LOGPID "/System/ApplicationData/RuntimeData/syslogd.pid"
 #endif
 #endif
 #endif
 
 #ifndef _PATH_DEV
-#define _PATH_DEV	"/dev/"
+#define _PATH_DEV	"/System/Devices/"
 #endif
 
 #ifndef _PATH_CONSOLE
-#define _PATH_CONSOLE	"/dev/console"
+#define _PATH_CONSOLE	"/System/Devices/console"
 #endif
 
 #ifndef _PATH_TTY
-#define _PATH_TTY	"/dev/tty"
+#define _PATH_TTY	"/System/Devices/tty"
 #endif
 
 #ifndef _PATH_LOG
-#define _PATH_LOG	"/dev/log"
+#define _PATH_LOG	"/System/Devices/log"
 #endif
 
 char	*ConfFile = _PATH_LOGCONF;
@@ -890,11 +923,11 @@
 		dprintf("Checking pidfile.\n");
 		if (!check_pid(PidFile))
 		{
+			signal (SIGTERM, doexit);
 			if (fork()) {
 				/*
 				 * Parent process
 				 */
-				signal (SIGTERM, doexit);
 				sleep(300);
 				/*
 				 * Not reached unless something major went wrong.  5
@@ -992,6 +1025,7 @@
 	(void) signal(SIGCHLD, reapchild);
 	(void) signal(SIGALRM, domark);
 	(void) signal(SIGUSR1, Debug ? debug_switch : SIG_IGN);
+	(void) signal(SIGXFSZ, SIG_IGN);
 	(void) alarm(TIMERINTVL);
 
 	/* Create a partial message table for all file descriptors. */
@@ -1141,13 +1175,13 @@
 				 */
 				printchopped(from, line, \
  					     i + 2,  finet);
-			} else if (i < 0 && errno != EINTR) {
+			} else if (i < 0 && errno != EINTR && errno != EAGAIN) {
 				dprintf("INET socket error: %d = %s.\n", \
 					errno, strerror(errno));
 				logerror("recvfrom inet");
 				/* should be harmless now that we set
 				 * BSDCOMPAT on the socket */
-				sleep(10);
+				sleep(1);
 			}
 		}
 #endif
@@ -1216,6 +1250,7 @@
 {
 	int fd, on = 1;
 	struct sockaddr_in sin;
+	int sockflags;
 
 	fd = socket(AF_INET, SOCK_DGRAM, 0);
 	if (fd < 0) {
@@ -1241,6 +1276,24 @@
 		close(fd);
 		return -1;
 	}
+	/* We must not block on the network socket, in case a packet
+	 * gets lost between select and recv, otherise the process
+	 * will stall until the timeout, and other processes trying to
+	 * log will also stall.
+	 */
+	if ((sockflags = fcntl(fd, F_GETFL)) != -1) {
+		sockflags |= O_NONBLOCK;
+		/*
+		 * SETFL could fail too, so get it caught by the subsequent
+		 * error check.
+		 */
+		sockflags = fcntl(fd, F_SETFL, sockflags);
+	}
+	if (sockflags == -1) {
+		logerror("fcntl(O_NONBLOCK), suspending inet");
+		close(fd);
+		return -1;
+	}
 	if (bind(fd, (struct sockaddr *) &sin, sizeof(sin)) < 0) {
 		logerror("bind, suspending inet");
 		close(fd);
@@ -1254,30 +1307,26 @@
 crunch_list(list)
 	char *list;
 {
-	int count, i;
+	int i, m, n;
 	char *p, *q;
 	char **result = NULL;
 
 	p = list;
 	
 	/* strip off trailing delimiters */
-	while (p[strlen(p)-1] == LIST_DELIMITER) {
-		count--;
+	while (*p && p[strlen(p)-1] == LIST_DELIMITER)
 		p[strlen(p)-1] = '\0';
-	}
 	/* cut off leading delimiters */
-	while (p[0] == LIST_DELIMITER) {
-		count--;
+	while (p[0] == LIST_DELIMITER)
 		p++; 
-	}
 	
-	/* count delimiters to calculate elements */
-	for (count=i=0; p[i]; i++)
-		if (p[i] == LIST_DELIMITER) count++;
+	/* count delimiters to calculate the number of elements */
+	for (n = i = 0; p[i]; i++)
+		if (p[i] == LIST_DELIMITER) n++;
 	
-	if ((result = (char **)malloc(sizeof(char *) * count+2)) == NULL) {
+	if ((result = (char **)malloc(sizeof(char *) * (n + 2))) == NULL) {
 		printf ("Sorry, can't get enough memory, exiting.\n");
-		exit(0);
+		exit(1);
 	}
 	
 	/*
@@ -1285,30 +1334,28 @@
 	 * characters are different from any delimiters,
 	 * so we don't have to care about this.
 	 */
-	count = 0;
-	while ((q=strchr(p, LIST_DELIMITER))) {
-		result[count] = (char *) malloc((q - p + 1) * sizeof(char));
-		if (result[count] == NULL) {
+	m = 0;
+	while ((q = strchr(p, LIST_DELIMITER)) && m < n) {
+		result[m] = (char *) malloc((q - p + 1) * sizeof(char));
+		if (result[m] == NULL) {
 			printf ("Sorry, can't get enough memory, exiting.\n");
-			exit(0);
+			exit(1);
 		}
-		strncpy(result[count], p, q - p);
-		result[count][q - p] = '\0';
+		memcpy(result[m], p, q - p);
+		result[m][q - p] = '\0';
 		p = q; p++;
-		count++;
+		m++;
 	}
-	if ((result[count] = \
-	     (char *)malloc(sizeof(char) * strlen(p) + 1)) == NULL) {
+	if ((result[m] = strdup(p)) == NULL) {
 		printf ("Sorry, can't get enough memory, exiting.\n");
-		exit(0);
+		exit(1);
 	}
-	strcpy(result[count],p);
-	result[++count] = NULL;
+	result[++m] = NULL;
 
 #if 0
-	count=0;
-	while (result[count])
-		dprintf ("#%d: %s\n", count, StripDomains[count++]);
+	m = 0;
+	while (result[m])
+		dprintf ("#%d: %s\n", m, result[m++]);
 #endif
 	return result;
 }
@@ -1466,7 +1513,7 @@
 
 
 /*
- * Take a raw input line from /dev/klog, split and format similar to syslog().
+ * Take a raw input line from /System/Devices/klog, split and format similar to syslog().
  */
 
 void printsys(msg)
@@ -1548,21 +1595,25 @@
 
 	/*
 	 * Check to see if msg looks non-standard.
+	 *
+	 * A message looks like
+	 * Nov 17 11:42:33 CRON[
+	 * 01234567890123456
+	 *    ^  ^  ^  ^  ^
+	 *
+	 * Remote messages are not accompanied by a timestamp.
+	 * Local messages are accompanied by a timestamp (program's timezone)
 	 */
 	msglen = strlen(msg);
-	if (msglen < 16 || msg[3] != ' ' || msg[6] != ' ' ||
-	    msg[9] != ':' || msg[12] != ':' || msg[15] != ' ')
-		flags |= ADDDATE;
-
-	(void) time(&now);
-	if (flags & ADDDATE)
-		timestamp = ctime(&now) + 4;
-	else {
-		timestamp = msg;
+	if (!(msglen < 16 || msg[3] != ' ' || msg[6] != ' ' ||
+	    msg[9] != ':' || msg[12] != ':' || msg[15] != ' ')) {
 		msg += 16;
 		msglen -= 16;
 	}
 
+	(void) time(&now);
+	timestamp = ctime(&now) + 4;
+
 	/* extract facility and priority level */
 	if (flags & MARK)
 		fac = LOG_NFACILITIES;
@@ -1771,7 +1822,7 @@
 			dprintf("Not sending message to remote.\n");
 		else {
 			f->f_time = now;
-			(void) snprintf(line, sizeof(line), "<%d>%s\n", f->f_prevpri, \
+			(void) snprintf(line, sizeof(line), "<%d>%s", f->f_prevpri, \
 				(char *) iov[4].iov_base);
 			l = strlen(line);
 			if (l > MAXLINE)
@@ -1815,7 +1866,7 @@
 			v->iov_len = 1;
 		}
 	again:
-		/* f->f_file == -1 is an indicator that the we couldn't
+		/* f->f_file == -1 is an indicator that we couldn't
 		   open the file at startup. */
 		if (f->f_file == -1)
 			break;
@@ -1852,7 +1903,7 @@
 				errno = e;
 				logerror(f->f_un.f_fname);
 			}
-		} else if (f->f_flags & SYNC_FILE)
+		} else if (f->f_type == F_FILE && (f->f_flags & SYNC_FILE))
 			(void) fsync(f->f_file);
 		break;
 
@@ -1891,7 +1942,7 @@
 	register struct filed *f;
 	struct iovec *iov;
 {
-	char p[6 + UNAMESZ];
+	char p[sizeof (_PATH_DEV) + UNAMESZ];
 	register int i;
 	int ttyf, len;
 	static int reenter = 0;
@@ -1899,6 +1950,8 @@
 	struct utmp *uptr;
 	char greetings[200];
 
+	(void) &len;
+
 	if (reenter++)
 		return;
 
@@ -1913,7 +1966,6 @@
 	if (fork() == 0) {
 		(void) signal(SIGTERM, SIG_DFL);
 		(void) alarm(0);
-		(void) signal(SIGALRM, endtty);
 #ifndef SYSV
 		(void) signal(SIGTTOU, SIG_IGN);
 		(void) sigsetmask(0);
@@ -1929,7 +1981,7 @@
 			/* is this slot used? */
 			if (ut.ut_name[0] == '\0')
 				continue;
-			if (ut.ut_type == LOGIN_PROCESS)
+			if (ut.ut_type != USER_PROCESS)
 			        continue;
 			if (!(strcmp (ut.ut_name,"LOGIN"))) /* paranoia */
 			        continue;
@@ -1959,6 +2011,7 @@
 				iov[1].iov_len = 0;
 			}
 			if (setjmp(ttybuf) == 0) {
+				(void) signal(SIGALRM, endtty);
 				(void) alarm(15);
 				/* open the terminal */
 				ttyf = open(p, O_WRONLY|O_NOCTTY);
